// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/amikhailau/users-service/pkg/pb/service.proto

// Generated with protoc-gen-gorm version: master
// Anticipating compatibility with atlas-app-toolkit version: master

/*
Package pb is a generated protocol buffer package.

It is generated from these files:
	github.com/amikhailau/users-service/pkg/pb/service.proto

It has these top-level messages:
	VersionResponse
	User
	CreateUserRequest
	CreateUserResponse
	ReadUserRequest
	ReadUserResponse
	UpdateUserRequest
	UpdateUserResponse
	DeleteUserRequest
	DeleteUserResponse
	ListUsersRequest
	ListUsersResponse
	StoreItem
	CreateStoreItemRequest
	CreateStoreItemResponse
	ReadStoreItemRequest
	ReadStoreItemResponse
	UpdateStoreItemRequest
	UpdateStoreItemResponse
	DeleteStoreItemRequest
	DeleteStoreItemResponse
	ListStoreItemsRequest
	ListStoreItemsResponse
	BuyByUserRequest
	BuyByUserResponse
	GetUserItemsIdsRequest
	GetUserItemsIdsResponse
	UserStats
	ReadUserStatsRequest
	ReadUserStatsResponse
	UpdateUserStatsRequest
	UpdateUserStatsResponse
	News
	CreateNewsRequest
	CreateNewsResponse
	ReadNewsRequest
	ReadNewsResponse
	UpdateNewsRequest
	UpdateNewsResponse
	ListNewsRequest
	ListNewsResponse
*/
package pb

import context "context"
import fmt "fmt"
import strings "strings"
import time "time"

import errors1 "github.com/infobloxopen/protoc-gen-gorm/errors"
import field_mask1 "google.golang.org/genproto/protobuf/field_mask"
import gorm1 "github.com/jinzhu/gorm"
import gorm2 "github.com/infobloxopen/atlas-app-toolkit/gorm"
import ptypes1 "github.com/golang/protobuf/ptypes"
import query1 "github.com/infobloxopen/atlas-app-toolkit/query"

import math "math"
import _ "github.com/golang/protobuf/ptypes/empty"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/envoyproxy/protoc-gen-validate/validate"
import _ "github.com/grpc-ecosystem/grpc-gateway/protoc-gen-swagger/options"
import _ "google.golang.org/genproto/protobuf/field_mask"
import _ "github.com/golang/protobuf/ptypes/timestamp"
import _ "github.com/infobloxopen/atlas-app-toolkit/query"
import _ "github.com/infobloxopen/protoc-gen-atlas-query-validate/options"
import _ "github.com/infobloxopen/protoc-gen-atlas-validate/options"

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = math.Inf

type UserORM struct {
	Coins    int64
	Email    string
	Gems     int64
	Id       string          `gorm:"type:UUID;primary_key"`
	Items    []*StoreItemORM `gorm:"foreignkey:Id;association_foreignkey:Id;many2many:users_store_items;jointable_foreignkey:user_id;association_jointable_foreignkey:store_item_id;preload:false"`
	Name     string
	Password string
	Stats    *UserStatsORM `gorm:"foreignkey:UserId;association_foreignkey:Id"`
}

// TableName overrides the default tablename generated by GORM
func (UserORM) TableName() string {
	return "users"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *User) ToORM(ctx context.Context) (UserORM, error) {
	to := UserORM{}
	var err error
	if prehook, ok := interface{}(m).(UserWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Email = m.Email
	to.Password = m.Password
	to.Coins = m.Coins
	to.Gems = m.Gems
	for _, v := range m.Items {
		if v != nil {
			if tempItems, cErr := v.ToORM(ctx); cErr == nil {
				to.Items = append(to.Items, &tempItems)
			} else {
				return to, cErr
			}
		} else {
			to.Items = append(to.Items, nil)
		}
	}
	if m.Stats != nil {
		tempStats, err := m.Stats.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Stats = &tempStats
	}
	if posthook, ok := interface{}(m).(UserWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *UserORM) ToPB(ctx context.Context) (User, error) {
	to := User{}
	var err error
	if prehook, ok := interface{}(m).(UserWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Email = m.Email
	to.Password = m.Password
	to.Coins = m.Coins
	to.Gems = m.Gems
	for _, v := range m.Items {
		if v != nil {
			if tempItems, cErr := v.ToPB(ctx); cErr == nil {
				to.Items = append(to.Items, &tempItems)
			} else {
				return to, cErr
			}
		} else {
			to.Items = append(to.Items, nil)
		}
	}
	if m.Stats != nil {
		tempStats, err := m.Stats.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Stats = &tempStats
	}
	if posthook, ok := interface{}(m).(UserWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type User the arg will be the target, the caller the one being converted from

// UserBeforeToORM called before default ToORM code
type UserWithBeforeToORM interface {
	BeforeToORM(context.Context, *UserORM) error
}

// UserAfterToORM called after default ToORM code
type UserWithAfterToORM interface {
	AfterToORM(context.Context, *UserORM) error
}

// UserBeforeToPB called before default ToPB code
type UserWithBeforeToPB interface {
	BeforeToPB(context.Context, *User) error
}

// UserAfterToPB called after default ToPB code
type UserWithAfterToPB interface {
	AfterToPB(context.Context, *User) error
}

type StoreItemORM struct {
	CoinsPrice  int64
	Description string
	GemsPrice   int64
	Id          string `gorm:"type:UUID;primary_key"`
	ImageId     string
	Name        string
	Type        int64
}

// TableName overrides the default tablename generated by GORM
func (StoreItemORM) TableName() string {
	return "store_items"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *StoreItem) ToORM(ctx context.Context) (StoreItemORM, error) {
	to := StoreItemORM{}
	var err error
	if prehook, ok := interface{}(m).(StoreItemWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Description = m.Description
	to.Type = m.Type
	to.CoinsPrice = m.CoinsPrice
	to.GemsPrice = m.GemsPrice
	to.ImageId = m.ImageId
	if posthook, ok := interface{}(m).(StoreItemWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *StoreItemORM) ToPB(ctx context.Context) (StoreItem, error) {
	to := StoreItem{}
	var err error
	if prehook, ok := interface{}(m).(StoreItemWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Description = m.Description
	to.Type = m.Type
	to.CoinsPrice = m.CoinsPrice
	to.GemsPrice = m.GemsPrice
	to.ImageId = m.ImageId
	if posthook, ok := interface{}(m).(StoreItemWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type StoreItem the arg will be the target, the caller the one being converted from

// StoreItemBeforeToORM called before default ToORM code
type StoreItemWithBeforeToORM interface {
	BeforeToORM(context.Context, *StoreItemORM) error
}

// StoreItemAfterToORM called after default ToORM code
type StoreItemWithAfterToORM interface {
	AfterToORM(context.Context, *StoreItemORM) error
}

// StoreItemBeforeToPB called before default ToPB code
type StoreItemWithBeforeToPB interface {
	BeforeToPB(context.Context, *StoreItem) error
}

// StoreItemAfterToPB called after default ToPB code
type StoreItemWithAfterToPB interface {
	AfterToPB(context.Context, *StoreItem) error
}

type UserStatsORM struct {
	Games  int64
	Id     int64 `gorm:"type:serial;primary_key"`
	Kills  int64
	Top5   int64
	UserId *string
	Wins   int64
}

// TableName overrides the default tablename generated by GORM
func (UserStatsORM) TableName() string {
	return "user_stats"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *UserStats) ToORM(ctx context.Context) (UserStatsORM, error) {
	to := UserStatsORM{}
	var err error
	if prehook, ok := interface{}(m).(UserStatsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Games = m.Games
	to.Wins = m.Wins
	to.Top5 = m.Top5
	to.Kills = m.Kills
	if posthook, ok := interface{}(m).(UserStatsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *UserStatsORM) ToPB(ctx context.Context) (UserStats, error) {
	to := UserStats{}
	var err error
	if prehook, ok := interface{}(m).(UserStatsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Games = m.Games
	to.Wins = m.Wins
	to.Top5 = m.Top5
	to.Kills = m.Kills
	if posthook, ok := interface{}(m).(UserStatsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type UserStats the arg will be the target, the caller the one being converted from

// UserStatsBeforeToORM called before default ToORM code
type UserStatsWithBeforeToORM interface {
	BeforeToORM(context.Context, *UserStatsORM) error
}

// UserStatsAfterToORM called after default ToORM code
type UserStatsWithAfterToORM interface {
	AfterToORM(context.Context, *UserStatsORM) error
}

// UserStatsBeforeToPB called before default ToPB code
type UserStatsWithBeforeToPB interface {
	BeforeToPB(context.Context, *UserStats) error
}

// UserStatsAfterToPB called after default ToPB code
type UserStatsWithAfterToPB interface {
	AfterToPB(context.Context, *UserStats) error
}

type NewsORM struct {
	Date        *time.Time
	Description string
	Id          string `gorm:"type:UUID;primary_key"`
	ImageLink   string
	Title       string
}

// TableName overrides the default tablename generated by GORM
func (NewsORM) TableName() string {
	return "news"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *News) ToORM(ctx context.Context) (NewsORM, error) {
	to := NewsORM{}
	var err error
	if prehook, ok := interface{}(m).(NewsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.Date != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.Date); err != nil {
			return to, err
		}
		to.Date = &t
	}
	to.Title = m.Title
	to.Description = m.Description
	to.ImageLink = m.ImageLink
	if posthook, ok := interface{}(m).(NewsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *NewsORM) ToPB(ctx context.Context) (News, error) {
	to := News{}
	var err error
	if prehook, ok := interface{}(m).(NewsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.Date != nil {
		if to.Date, err = ptypes1.TimestampProto(*m.Date); err != nil {
			return to, err
		}
	}
	to.Title = m.Title
	to.Description = m.Description
	to.ImageLink = m.ImageLink
	if posthook, ok := interface{}(m).(NewsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type News the arg will be the target, the caller the one being converted from

// NewsBeforeToORM called before default ToORM code
type NewsWithBeforeToORM interface {
	BeforeToORM(context.Context, *NewsORM) error
}

// NewsAfterToORM called after default ToORM code
type NewsWithAfterToORM interface {
	AfterToORM(context.Context, *NewsORM) error
}

// NewsBeforeToPB called before default ToPB code
type NewsWithBeforeToPB interface {
	BeforeToPB(context.Context, *News) error
}

// NewsAfterToPB called after default ToPB code
type NewsWithAfterToPB interface {
	AfterToPB(context.Context, *News) error
}

// DefaultCreateUser executes a basic gorm create call
func DefaultCreateUser(ctx context.Context, in *User, db *gorm1.DB) (*User, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type UserORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type UserORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadUser executes a basic gorm read call
func DefaultReadUser(ctx context.Context, in *User, db *gorm1.DB) (*User, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &UserORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := UserORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(UserORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type UserORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type UserORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type UserORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteUser(ctx context.Context, in *User, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&UserORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type UserORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type UserORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteUserSet(ctx context.Context, in []*User, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&UserORM{})).(UserORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&UserORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&UserORM{})).(UserORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type UserORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*User, *gorm1.DB) (*gorm1.DB, error)
}
type UserORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*User, *gorm1.DB) error
}

// DefaultStrictUpdateUser clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateUser(ctx context.Context, in *User, db *gorm1.DB) (*User, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateUser")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &UserORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Model(&ormObj).Association("Items").Replace(ormObj.Items).Error; err != nil {
		return nil, err
	}
	ormObj.Items = nil
	filterStats := UserStatsORM{}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	filterStats.UserId = new(string)
	*filterStats.UserId = ormObj.Id
	if err = db.Where(filterStats).Delete(UserStatsORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type UserORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type UserORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type UserORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchUser executes a basic gorm update call with patch behavior
func DefaultPatchUser(ctx context.Context, in *User, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*User, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj User
	var err error
	if hook, ok := interface{}(&pbObj).(UserWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadUser(ctx, &User{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(UserWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskUser(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(UserWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateUser(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(UserWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type UserWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *User, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type UserWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *User, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type UserWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *User, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type UserWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *User, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetUser executes a bulk gorm update call with patch behavior
func DefaultPatchSetUser(ctx context.Context, objects []*User, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*User, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*User, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchUser(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskUser patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskUser(ctx context.Context, patchee *User, patcher *User, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*User, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedStats bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Email" {
			patchee.Email = patcher.Email
			continue
		}
		if f == prefix+"Password" {
			patchee.Password = patcher.Password
			continue
		}
		if f == prefix+"Coins" {
			patchee.Coins = patcher.Coins
			continue
		}
		if f == prefix+"Gems" {
			patchee.Gems = patcher.Gems
			continue
		}
		if f == prefix+"Items" {
			patchee.Items = patcher.Items
			continue
		}
		if !updatedStats && strings.HasPrefix(f, prefix+"Stats.") {
			updatedStats = true
			if patcher.Stats == nil {
				patchee.Stats = nil
				continue
			}
			if patchee.Stats == nil {
				patchee.Stats = &UserStats{}
			}
			if o, err := DefaultApplyFieldMaskUserStats(ctx, patchee.Stats, patcher.Stats, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Stats.", db); err != nil {
				return nil, err
			} else {
				patchee.Stats = o
			}
			continue
		}
		if f == prefix+"Stats" {
			updatedStats = true
			patchee.Stats = patcher.Stats
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListUser executes a gorm list call
func DefaultListUser(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*User, error) {
	in := User{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &UserORM{}, &User{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []UserORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*User{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type UserORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type UserORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type UserORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]UserORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateStoreItem executes a basic gorm create call
func DefaultCreateStoreItem(ctx context.Context, in *StoreItem, db *gorm1.DB) (*StoreItem, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StoreItemORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StoreItemORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type StoreItemORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type StoreItemORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadStoreItem executes a basic gorm read call
func DefaultReadStoreItem(ctx context.Context, in *StoreItem, db *gorm1.DB) (*StoreItem, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(StoreItemORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &StoreItemORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StoreItemORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := StoreItemORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(StoreItemORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type StoreItemORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type StoreItemORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type StoreItemORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteStoreItem(ctx context.Context, in *StoreItem, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(StoreItemORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&StoreItemORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(StoreItemORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type StoreItemORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type StoreItemORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteStoreItemSet(ctx context.Context, in []*StoreItem, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&StoreItemORM{})).(StoreItemORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&StoreItemORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&StoreItemORM{})).(StoreItemORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type StoreItemORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*StoreItem, *gorm1.DB) (*gorm1.DB, error)
}
type StoreItemORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*StoreItem, *gorm1.DB) error
}

// DefaultStrictUpdateStoreItem clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateStoreItem(ctx context.Context, in *StoreItem, db *gorm1.DB) (*StoreItem, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateStoreItem")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &StoreItemORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(StoreItemORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(StoreItemORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StoreItemORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type StoreItemORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type StoreItemORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type StoreItemORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchStoreItem executes a basic gorm update call with patch behavior
func DefaultPatchStoreItem(ctx context.Context, in *StoreItem, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*StoreItem, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj StoreItem
	var err error
	if hook, ok := interface{}(&pbObj).(StoreItemWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadStoreItem(ctx, &StoreItem{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(StoreItemWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskStoreItem(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(StoreItemWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateStoreItem(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(StoreItemWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type StoreItemWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *StoreItem, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type StoreItemWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *StoreItem, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type StoreItemWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *StoreItem, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type StoreItemWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *StoreItem, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetStoreItem executes a bulk gorm update call with patch behavior
func DefaultPatchSetStoreItem(ctx context.Context, objects []*StoreItem, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*StoreItem, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*StoreItem, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchStoreItem(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskStoreItem patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskStoreItem(ctx context.Context, patchee *StoreItem, patcher *StoreItem, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*StoreItem, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
		if f == prefix+"CoinsPrice" {
			patchee.CoinsPrice = patcher.CoinsPrice
			continue
		}
		if f == prefix+"GemsPrice" {
			patchee.GemsPrice = patcher.GemsPrice
			continue
		}
		if f == prefix+"ImageId" {
			patchee.ImageId = patcher.ImageId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListStoreItem executes a gorm list call
func DefaultListStoreItem(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*StoreItem, error) {
	in := StoreItem{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StoreItemORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &StoreItemORM{}, &StoreItem{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StoreItemORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []StoreItemORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StoreItemORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*StoreItem{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type StoreItemORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type StoreItemORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type StoreItemORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]StoreItemORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateUserStats executes a basic gorm create call
func DefaultCreateUserStats(ctx context.Context, in *UserStats, db *gorm1.DB) (*UserStats, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserStatsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserStatsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type UserStatsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type UserStatsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadUserStats executes a basic gorm read call
func DefaultReadUserStats(ctx context.Context, in *UserStats, db *gorm1.DB) (*UserStats, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UserStatsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &UserStatsORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserStatsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := UserStatsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(UserStatsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type UserStatsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type UserStatsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type UserStatsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteUserStats(ctx context.Context, in *UserStats, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UserStatsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&UserStatsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(UserStatsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type UserStatsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type UserStatsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteUserStatsSet(ctx context.Context, in []*UserStats, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&UserStatsORM{})).(UserStatsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&UserStatsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&UserStatsORM{})).(UserStatsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type UserStatsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*UserStats, *gorm1.DB) (*gorm1.DB, error)
}
type UserStatsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*UserStats, *gorm1.DB) error
}

// DefaultStrictUpdateUserStats clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateUserStats(ctx context.Context, in *UserStats, db *gorm1.DB) (*UserStats, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateUserStats")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &UserStatsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(UserStatsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(UserStatsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserStatsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type UserStatsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type UserStatsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type UserStatsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchUserStats executes a basic gorm update call with patch behavior
func DefaultPatchUserStats(ctx context.Context, in *UserStats, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*UserStats, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj UserStats
	var err error
	if hook, ok := interface{}(&pbObj).(UserStatsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadUserStats(ctx, &UserStats{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(UserStatsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskUserStats(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(UserStatsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateUserStats(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(UserStatsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type UserStatsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *UserStats, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type UserStatsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *UserStats, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type UserStatsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *UserStats, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type UserStatsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *UserStats, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetUserStats executes a bulk gorm update call with patch behavior
func DefaultPatchSetUserStats(ctx context.Context, objects []*UserStats, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*UserStats, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*UserStats, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchUserStats(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskUserStats patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskUserStats(ctx context.Context, patchee *UserStats, patcher *UserStats, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*UserStats, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Games" {
			patchee.Games = patcher.Games
			continue
		}
		if f == prefix+"Wins" {
			patchee.Wins = patcher.Wins
			continue
		}
		if f == prefix+"Top5" {
			patchee.Top5 = patcher.Top5
			continue
		}
		if f == prefix+"Kills" {
			patchee.Kills = patcher.Kills
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListUserStats executes a gorm list call
func DefaultListUserStats(ctx context.Context, db *gorm1.DB) ([]*UserStats, error) {
	in := UserStats{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserStatsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &UserStatsORM{}, &UserStats{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserStatsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []UserStatsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserStatsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*UserStats{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type UserStatsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type UserStatsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type UserStatsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]UserStatsORM) error
}

// DefaultCreateNews executes a basic gorm create call
func DefaultCreateNews(ctx context.Context, in *News, db *gorm1.DB) (*News, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NewsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NewsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type NewsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type NewsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadNews executes a basic gorm read call
func DefaultReadNews(ctx context.Context, in *News, db *gorm1.DB) (*News, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(NewsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &NewsORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NewsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := NewsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(NewsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type NewsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type NewsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type NewsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteNews(ctx context.Context, in *News, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(NewsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&NewsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(NewsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type NewsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type NewsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteNewsSet(ctx context.Context, in []*News, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&NewsORM{})).(NewsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&NewsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&NewsORM{})).(NewsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type NewsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*News, *gorm1.DB) (*gorm1.DB, error)
}
type NewsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*News, *gorm1.DB) error
}

// DefaultStrictUpdateNews clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateNews(ctx context.Context, in *News, db *gorm1.DB) (*News, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateNews")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &NewsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(NewsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(NewsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NewsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type NewsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type NewsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type NewsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchNews executes a basic gorm update call with patch behavior
func DefaultPatchNews(ctx context.Context, in *News, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*News, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj News
	var err error
	if hook, ok := interface{}(&pbObj).(NewsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadNews(ctx, &News{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(NewsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskNews(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(NewsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateNews(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(NewsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type NewsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *News, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type NewsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *News, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type NewsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *News, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type NewsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *News, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetNews executes a bulk gorm update call with patch behavior
func DefaultPatchSetNews(ctx context.Context, objects []*News, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*News, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*News, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchNews(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskNews patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskNews(ctx context.Context, patchee *News, patcher *News, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*News, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Date" {
			patchee.Date = patcher.Date
			continue
		}
		if f == prefix+"Title" {
			patchee.Title = patcher.Title
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"ImageLink" {
			patchee.ImageLink = patcher.ImageLink
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListNews executes a gorm list call
func DefaultListNews(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*News, error) {
	in := News{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NewsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &NewsORM{}, &News{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NewsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []NewsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NewsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*News{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type NewsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type NewsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type NewsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]NewsORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}
type UsersDefaultServer struct {
	DB *gorm1.DB
}

// Create ...
func (m *UsersDefaultServer) Create(ctx context.Context, in *CreateUserRequest) (*CreateUserResponse, error) {
	out := &CreateUserResponse{}
	return out, nil
}

// Read ...
func (m *UsersDefaultServer) Read(ctx context.Context, in *ReadUserRequest) (*ReadUserResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(UsersUserWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadUser(ctx, &User{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &ReadUserResponse{Result: res}
	if custom, ok := interface{}(in).(UsersUserWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// UsersUserWithBeforeRead called before DefaultReadUser in the default Read handler
type UsersUserWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// UsersUserWithAfterRead called before DefaultReadUser in the default Read handler
type UsersUserWithAfterRead interface {
	AfterRead(context.Context, *ReadUserResponse, *gorm1.DB) error
}

// Update ...
func (m *UsersDefaultServer) Update(ctx context.Context, in *UpdateUserRequest) (*UpdateUserResponse, error) {
	out := &UpdateUserResponse{}
	return out, nil
}

// Delete ...
func (m *UsersDefaultServer) Delete(ctx context.Context, in *DeleteUserRequest) (*DeleteUserResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(UsersUserWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteUser(ctx, &User{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteUserResponse{}
	if custom, ok := interface{}(in).(UsersUserWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// UsersUserWithBeforeDelete called before DefaultDeleteUser in the default Delete handler
type UsersUserWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// UsersUserWithAfterDelete called before DefaultDeleteUser in the default Delete handler
type UsersUserWithAfterDelete interface {
	AfterDelete(context.Context, *DeleteUserResponse, *gorm1.DB) error
}

// List ...
func (m *UsersDefaultServer) List(ctx context.Context, in *ListUsersRequest) (*ListUsersResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(UsersUserWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	pagedRequest := false
	if in.GetPaging().GetLimit() >= 1 {
		in.Paging.Limit++
		pagedRequest = true
	}
	res, err := DefaultListUser(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	var resPaging *query1.PageInfo
	if pagedRequest {
		var offset int32
		var size int32 = int32(len(res))
		if size == in.GetPaging().GetLimit() {
			size--
			res = res[:size]
			offset = in.GetPaging().GetOffset() + size
		}
		resPaging = &query1.PageInfo{Offset: offset}
	}
	out := &ListUsersResponse{Results: res, Page: resPaging}
	if custom, ok := interface{}(in).(UsersUserWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// UsersUserWithBeforeList called before DefaultListUser in the default List handler
type UsersUserWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// UsersUserWithAfterList called before DefaultListUser in the default List handler
type UsersUserWithAfterList interface {
	AfterList(context.Context, *ListUsersResponse, *gorm1.DB) error
}
type StoreItemsDefaultServer struct {
	DB *gorm1.DB
}

// Create ...
func (m *StoreItemsDefaultServer) Create(ctx context.Context, in *CreateStoreItemRequest) (*CreateStoreItemResponse, error) {
	out := &CreateStoreItemResponse{}
	return out, nil
}

// Read ...
func (m *StoreItemsDefaultServer) Read(ctx context.Context, in *ReadStoreItemRequest) (*ReadStoreItemResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(StoreItemsStoreItemWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadStoreItem(ctx, &StoreItem{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &ReadStoreItemResponse{Result: res}
	if custom, ok := interface{}(in).(StoreItemsStoreItemWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// StoreItemsStoreItemWithBeforeRead called before DefaultReadStoreItem in the default Read handler
type StoreItemsStoreItemWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// StoreItemsStoreItemWithAfterRead called before DefaultReadStoreItem in the default Read handler
type StoreItemsStoreItemWithAfterRead interface {
	AfterRead(context.Context, *ReadStoreItemResponse, *gorm1.DB) error
}

// Update ...
func (m *StoreItemsDefaultServer) Update(ctx context.Context, in *UpdateStoreItemRequest) (*UpdateStoreItemResponse, error) {
	var err error
	var res *StoreItem
	db := m.DB
	if custom, ok := interface{}(in).(StoreItemsStoreItemWithBeforeUpdate); ok {
		var err error
		if db, err = custom.BeforeUpdate(ctx, db); err != nil {
			return nil, err
		}
	}
	if in.GetFields() == nil {
		res, err = DefaultStrictUpdateStoreItem(ctx, in.GetPayload(), db)
	} else {
		res, err = DefaultPatchStoreItem(ctx, in.GetPayload(), in.GetFields(), db)
	}
	if err != nil {
		return nil, err
	}
	out := &UpdateStoreItemResponse{Result: res}
	if custom, ok := interface{}(in).(StoreItemsStoreItemWithAfterUpdate); ok {
		var err error
		if err = custom.AfterUpdate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// StoreItemsStoreItemWithBeforeUpdate called before DefaultUpdateStoreItem in the default Update handler
type StoreItemsStoreItemWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// StoreItemsStoreItemWithAfterUpdate called before DefaultUpdateStoreItem in the default Update handler
type StoreItemsStoreItemWithAfterUpdate interface {
	AfterUpdate(context.Context, *UpdateStoreItemResponse, *gorm1.DB) error
}

// Delete ...
func (m *StoreItemsDefaultServer) Delete(ctx context.Context, in *DeleteStoreItemRequest) (*DeleteStoreItemResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(StoreItemsStoreItemWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteStoreItem(ctx, &StoreItem{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteStoreItemResponse{}
	if custom, ok := interface{}(in).(StoreItemsStoreItemWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// StoreItemsStoreItemWithBeforeDelete called before DefaultDeleteStoreItem in the default Delete handler
type StoreItemsStoreItemWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// StoreItemsStoreItemWithAfterDelete called before DefaultDeleteStoreItem in the default Delete handler
type StoreItemsStoreItemWithAfterDelete interface {
	AfterDelete(context.Context, *DeleteStoreItemResponse, *gorm1.DB) error
}

// List ...
func (m *StoreItemsDefaultServer) List(ctx context.Context, in *ListStoreItemsRequest) (*ListStoreItemsResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(StoreItemsStoreItemWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	pagedRequest := false
	if in.GetPaging().GetLimit() >= 1 {
		in.Paging.Limit++
		pagedRequest = true
	}
	res, err := DefaultListStoreItem(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	var resPaging *query1.PageInfo
	if pagedRequest {
		var offset int32
		var size int32 = int32(len(res))
		if size == in.GetPaging().GetLimit() {
			size--
			res = res[:size]
			offset = in.GetPaging().GetOffset() + size
		}
		resPaging = &query1.PageInfo{Offset: offset}
	}
	out := &ListStoreItemsResponse{Results: res, Page: resPaging}
	if custom, ok := interface{}(in).(StoreItemsStoreItemWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// StoreItemsStoreItemWithBeforeList called before DefaultListStoreItem in the default List handler
type StoreItemsStoreItemWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// StoreItemsStoreItemWithAfterList called before DefaultListStoreItem in the default List handler
type StoreItemsStoreItemWithAfterList interface {
	AfterList(context.Context, *ListStoreItemsResponse, *gorm1.DB) error
}

// BuyByUser ...
func (m *StoreItemsDefaultServer) BuyByUser(ctx context.Context, in *BuyByUserRequest) (*BuyByUserResponse, error) {
	out := &BuyByUserResponse{}
	return out, nil
}

// GetUserItemsIds ...
func (m *StoreItemsDefaultServer) GetUserItemsIds(ctx context.Context, in *GetUserItemsIdsRequest) (*GetUserItemsIdsResponse, error) {
	out := &GetUserItemsIdsResponse{}
	return out, nil
}

type UsersStatsDefaultServer struct {
	DB *gorm1.DB
}

// GetStats ...
func (m *UsersStatsDefaultServer) GetStats(ctx context.Context, in *ReadUserStatsRequest) (*ReadUserStatsResponse, error) {
	out := &ReadUserStatsResponse{}
	return out, nil
}

// UpdateStats ...
func (m *UsersStatsDefaultServer) UpdateStats(ctx context.Context, in *UpdateUserStatsRequest) (*UpdateUserStatsResponse, error) {
	out := &UpdateUserStatsResponse{}
	return out, nil
}

type NewsServiceDefaultServer struct {
	DB *gorm1.DB
}

// Create ...
func (m *NewsServiceDefaultServer) Create(ctx context.Context, in *CreateNewsRequest) (*CreateNewsResponse, error) {
	out := &CreateNewsResponse{}
	return out, nil
}

// Read ...
func (m *NewsServiceDefaultServer) Read(ctx context.Context, in *ReadNewsRequest) (*ReadNewsResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(NewsServiceNewsWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadNews(ctx, &News{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &ReadNewsResponse{Result: res}
	if custom, ok := interface{}(in).(NewsServiceNewsWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// NewsServiceNewsWithBeforeRead called before DefaultReadNews in the default Read handler
type NewsServiceNewsWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// NewsServiceNewsWithAfterRead called before DefaultReadNews in the default Read handler
type NewsServiceNewsWithAfterRead interface {
	AfterRead(context.Context, *ReadNewsResponse, *gorm1.DB) error
}

// Update ...
func (m *NewsServiceDefaultServer) Update(ctx context.Context, in *UpdateNewsRequest) (*UpdateNewsResponse, error) {
	out := &UpdateNewsResponse{}
	return out, nil
}

// List ...
func (m *NewsServiceDefaultServer) List(ctx context.Context, in *ListNewsRequest) (*ListNewsResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(NewsServiceNewsWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	pagedRequest := false
	if in.GetPaging().GetLimit() >= 1 {
		in.Paging.Limit++
		pagedRequest = true
	}
	res, err := DefaultListNews(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	var resPaging *query1.PageInfo
	if pagedRequest {
		var offset int32
		var size int32 = int32(len(res))
		if size == in.GetPaging().GetLimit() {
			size--
			res = res[:size]
			offset = in.GetPaging().GetOffset() + size
		}
		resPaging = &query1.PageInfo{Offset: offset}
	}
	out := &ListNewsResponse{Results: res, Page: resPaging}
	if custom, ok := interface{}(in).(NewsServiceNewsWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// NewsServiceNewsWithBeforeList called before DefaultListNews in the default List handler
type NewsServiceNewsWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// NewsServiceNewsWithAfterList called before DefaultListNews in the default List handler
type NewsServiceNewsWithAfterList interface {
	AfterList(context.Context, *ListNewsResponse, *gorm1.DB) error
}
